<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Visor VSLAM del Robot</title>
    <style>
        body { background-color: #14141e; color: #f0f0f0; font-family: sans-serif; text-align: center; margin: 0; padding-top: 20px; }
        h1 { margin-bottom: 20px; }
        canvas { background-color: #282832; border: 1px solid #3c3c46; }
    </style>
</head>
<body>

    <h1>VSLAM</h1>
    <div id="configPanel" style="margin-bottom: 16px;"></div>
    <canvas id="vslamCanvas" width="800" height="800"></canvas>

    <script>
        const canvas = document.getElementById('vslamCanvas');
        const ctx = canvas.getContext('2d');

        const COLORS = {
            '-1': '#22222a', // desconocido
            '0': '#181820',  // vacío
            '1': '#64646e',  // obstáculo
            '2': '#e23232',  // gnomo
            '3': '#cccccc',  // base
            '4': '#8b4513'   // terreno lento
        };
        const ROBOT_COLOR = '#3296fa';

        function drawMap(data) {
            const grid = data.memory_grid;
            const robotPos = data.robot_pos;

            const gridWidth = data.grid_width;
            const gridHeight = data.grid_height;
            
            const cellSize = canvas.width / gridWidth;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < gridHeight; r++) {
                for (let c = 0; c < gridWidth; c++) {
                    const cellType = grid[r][c];
                    ctx.fillStyle = COLORS[cellType.toString()] || COLORS['-1'];
                    ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
                }
            }
            
            ctx.fillStyle = ROBOT_COLOR;
            ctx.fillRect(robotPos[1] * cellSize, robotPos[0] * cellSize, cellSize, cellSize);

            for (let i = 0; i <= gridWidth; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.strokeStyle = '#14141e';
                ctx.stroke();
            }
            for (let i = 0; i <= gridHeight; i++) {
                 ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
        }


        async function updateMap() {
            try {
                const response = await fetch('http://localhost:8000/mapdata');
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                if (data.memory_grid && data.memory_grid.length > 0) {
                   drawMap(data);
                }
            } catch (error) {
                console.error("No se pudo actualizar el mapa:", error);
            }
        }


        // Mostrar la configuración en el panel
        async function showConfig() {
            try {
                const response = await fetch('http://localhost:8000/config');
                if (!response.ok) throw new Error('No se pudo obtener la configuración');
                const config = await response.json();
                const panel = document.getElementById('configPanel');
                panel.innerHTML = '<b>Configuración actual:</b><br>' +
                    Object.entries(config).map(([k, v]) => `${k}: <span style="color:#8cf">${v}</span>`).join(' | ');
            } catch (e) {
                document.getElementById('configPanel').innerText = 'No se pudo cargar la configuración.';
            }
        }

        showConfig();
        setInterval(updateMap, 100);
    </script>
</body>
</html>